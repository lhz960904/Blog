import{_ as o,c as a,o as n,O as l,z as e,a as t}from"./chunks/framework.d7e37bdc.js";const C=JSON.parse('{"title":"JavaScript中的防抖函数与节流函数","description":"","frontmatter":{"category":"技术","tags":["javascript"],"date":"2019-03-13T00:00:00.000Z","title":"JavaScript中的防抖函数与节流函数"},"headers":[],"relativePath":"posts/throttling-and-debouncing.md","filePath":"posts/throttling-and-debouncing.md"}'),i={name:"posts/throttling-and-debouncing.md"},r=l("",12),h=e("iframe",{height:"300",style:{width:"100%"},scrolling:"no",title:"Debounce. Trailing",src:"https://codepen.io/lhz960904/embed/YgEvjq?height=252&theme-id=dark&default-tab=result",frameborder:"no",allowtransparency:"true",allowfullscreen:"true"},`
  See the Pen <a href='https://codepen.io/lhz960904/pen/YgEvjq'>Debounce. Trailing</a> by lihaoze
  (<a href='https://codepen.io/lhz960904'>@lhz960904</a>) on <a href='https://codepen.io'>CodePen</a>.
`,-1),s=e("h3",{id:"延时开始前执行-leading",tabindex:"-1"},[t("延时开始前执行(leading) "),e("a",{class:"header-anchor",href:"#延时开始前执行-leading","aria-label":'Permalink to "延时开始前执行(leading)"'},"​")],-1),c=e("p",null,[e("img",{src:"https://camo.githubusercontent.com/48f5b715521474ca82958bd34e3e146b5d9b34f2/687474703a2f2f63646e2e6968616f7a652e636e2f5765636861744932303731372e706e67",alt:""})],-1),d=e("p",null,"如上图，延时开始前执行是指在这段延时时间内，连续的触发函数，只会在最开始执行一次。其原理是设置延时器前执行一次真正的函数，这时定时器作用只是为了标识此次延时时间内不能执行函数。这种延时开始前执行使用场景比较少，例如：",-1),p=e("ol",null,[e("li",null,"当用户点击刷新按钮时，可以尽早的执行函数。因为前后执行其实是一样的效果。本质上只是为了防止用户疯狂刷新")],-1),u=e("p",null,[t("同样，我们可以点击下方demo，通过不同频率的点击"),e("code",null,"Click"),t("进行测试。")],-1),_=e("iframe",{height:"300",style:{width:"100%"},scrolling:"no",title:"Debounce. Leading",src:"https://codepen.io/lhz960904/embed/drZeRg?height=265&theme-id=dark&default-tab=result",frameborder:"no",allowtransparency:"true",allowfullscreen:"true"},`
  See the Pen <a href='https://codepen.io/lhz960904/pen/drZeRg'>Debounce. Leading</a> by lihaoze
  (<a href='https://codepen.io/lhz960904'>@lhz960904</a>) on <a href='https://codepen.io'>CodePen</a>.
`,-1),g=e("h2",{id:"节流函数",tabindex:"-1"},[t("节流函数 "),e("a",{class:"header-anchor",href:"#节流函数","aria-label":'Permalink to "节流函数"'},"​")],-1),b=e("blockquote",null,[e("p",null,"节流函数的原理其实和防抖函数基本相同，不同的是，节流函数会设置一个最长等待执行时间，也就是说节流函数控制在一定时间内函数一定会执行一次。")],-1),f=e("p",null,"像之前的防抖函数(延时结束后执行)，如果我们一直在触发事件，那延时器会一直处于重置状态，真正的函数永远不会被执行，而节流函数会保证在一定时间内，执行一次。想象一下，如果我们要实现触底加载功能，监听scroll事件，在滚动状态下，我们不仅要控制频次，还需要隔一段时间去检查距底部距离。 这时，我们就需要节流函数(throttle)来控制。",-1),m=e("p",null,"同样你可以通过下方demo进行左右侧的滚动测试，左侧因为使用debounce进行控制，只有当滚动停止时才会判断距底部距离，所以会造成卡顿的效果，而右边的通过throttle控制，体验上要好。",-1),k=e("iframe",{height:"300",style:{width:"100%"},scrolling:"no",title:"throttle",src:"https://codepen.io/lhz960904/embed/RdjEoE?height=265&theme-id=dark&default-tab=result",frameborder:"no",allowtransparency:"true",allowfullscreen:"true"},`
  See the Pen <a href='https://codepen.io/lhz960904/pen/RdjEoE'>throttle</a> by lihaoze
  (<a href='https://codepen.io/lhz960904'>@lhz960904</a>) on <a href='https://codepen.io'>CodePen</a>.
`,-1),z=e("h2",{id:"参考",tabindex:"-1"},[t("参考 "),e("a",{class:"header-anchor",href:"#参考","aria-label":'Permalink to "参考"'},"​")],-1),P=e("ul",null,[e("li",null,[e("a",{href:"https://css-tricks.com/debouncing-throttling-explained-examples/",target:"_blank",rel:"noreferrer"},"https://css-tricks.com/debouncing-throttling-explained-examples/")])],-1),x=[r,h,s,c,d,p,u,_,g,b,f,m,k,z,P];function q(S,T,y,w,D,E){return n(),a("div",null,x)}const j=o(i,[["render",q]]);export{C as __pageData,j as default};
